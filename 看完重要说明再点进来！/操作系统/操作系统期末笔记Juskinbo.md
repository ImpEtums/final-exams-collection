# 操作系统期末笔记

操作系统的作用：

- 操作系统是一种管理**硬件资源**的软件。

操作系统的基本特征：

- 并发
- 资源共享

操作系统中的资源：

- CPU
- 内存
- 硬盘
- 网络
- 输入/输出设备

中断：

- 在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件使得 CPU 暂时中断当前正在执行的程序而转去执行相应的时间处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。
- 外部中断、trap、exception 三者的区别：
    - 外部中断是由当前计算机外部事件引起的中断，例如输入输出设备的请求、时钟中断等，当外部中断发生时，CPU 会停止正在执行的程序，保存当前程序的状态，然后跳转到相应的中断处理程序执行。
    - trap 是当前程序中指令引起的中断，当程序执行到一个 trap 指令时，CPU 会停止当前程序的执行，保存当前程序的状态，然后跳转到相应的 trap 处理程序执行，通常用于系统调用。
    - exception 是由 CPU 执行指令时检测到的错误或异常情况引起的中断（运行代码时经常能遇到），例如除0，访问非法地址，当异常发生时，CPU会停止当前程序的执行，保存当前程序的状态，然后跳转到相应的异常处理程序执行。

直接内存访问：

- DMA
- 允许外围设备和主内存之间直接传输他们的 I/O 数据，而不需要系统处理器参与。

中断和 DMA 的区别：

- 中断是在数据缓冲寄存器满了之后，要求 CPU 进行中断处理。
- DMA 方式是在所要求的数据块全部结束之后要求 CPU 进行中断，有 DMA 控制器进行控制，不需要 CPU 太多资源，大大减少了 CPU 中断的次数。![image-20230611231418811](https://s2.loli.net/2023/06/11/VxpJWuPdyr6NoGL.png)

内存与 USB 外设不直接连接。

内存和 Graphic 以及 Disk 是通过 DMA 方式进行连接的。

多 CPU、多核的区别：

- 多 CPU 是指一个主板上存在多个 CPU，即多个处理器芯片。
- 多核是指一个 CPU 上有多个处理器核心。
- 一般来说，多 CPU 系统比单 CPU 系统拥有更多的处理器核心，性能也就越强，能够应付更大的数量处理工作。

多道程序设计系统

- 定义
    - 多道程序设计是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。（在某一时间段内穿插着运行不同的程序，从而提高计算机的资源利用效率）
- 特征
    - 间断性
    - 共享性
    - 制约性

- 工作图
- 分时系统
    - 分时系统要求计算机系统是可交互（interactive）的，以便用户与系统直接通信。用户通过输入设备，如键盘、鼠标、触摸板、触摸屏等向操作系统或程序发出指令，并等待输出设备的即时结果。相应地，响应时间（response time）应当较短，通常小于 1 秒。

操作系统的双重模式

- 用户模式
    - 在用户模式下，执行代码无法直接访问硬件或参考内存。以用户模式运行的代码必须委托给系统API才能访问硬件或内存。由于这种隔离所提供的保护，用户模式下的崩溃始终是可恢复的.您计算机上运行的大多数代码都将以用户模式执行。
- 内核模式
    - 在内核模式下，执行代码具有对底层硬件的完全且不受限制的访问。它可以执行任何CPU指令并引用任何内存地址。内核模式通常保留给操作系统的最低级别，最受信任的功能。内核模式下的崩溃是灾难性的，他们将停止整个PC。
- 模式之间的切换
    - 当计算机系统表示用户应用程序正在执行，系统处于用户模式，然而，当用户应用程序需要操作系统的服务（通过系统调用），它必须从用户模式转换过来执行请求。
    - 硬件提供模式位 mode bit 用于区分操作系统执行的任务和为用户执行的任务，mode bit 为0的时候表示操作系统执行的任务，即内核模式，mode bit 为1的时候表示为用户执行的任务。

操作系统提供给用户的界面

- GUI（图形用户界面）
    - 比如 Windows 桌面等
- 命令行
    - 一般来说指的是各种命令，比如 Linux 下的`ls`、`cd`等
- 批处理
    - 也称为批处理脚本，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于 DOS 和 Windows 系统中

命令解释器，Shell

- 命令解释器就是 Shell，它是用户与操作系统内核之间的接口，用户可以通过 Shell 执行各种操作系统命令和程序，例如创建文件、复制文件、启动应用程序等。Shell 还可以用来编写脚本，将多个命令组合在一起执行，从而自动化一些重复性操作
- 常见的 Shell 有包括 Unix/Linux 下的 Bash、Zsh，Windows 下的 cmd、powershell 等

系统调用

- 系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。

库函数

- 把函数放到库里，供别人使用的一种方式。.方法是把一些常用到的函数编完放到一个文件里，供不同的人进行调用。分两类，一类是 C 语言标准规定的库函数，一类是编译器特定的库函数。

系统调用与库函数得区别

- （相对）专业解释：
    - 系统调用是操作系统提供的接口，用于访问操作系统的服务和资源，例如文件、网络、进程等。系统调用需要通过操作系统内核进行处理，因此执行效率比较低。常见的系统调用包括 open、read、write、close 等。库函数是编程语言提供的接口，用于访问编程语言提供的功能和资源，例如字符串处理、数学计算、文件操作等。库函数的实现通常是基于系统调用，但是它们是在用户空间中执行的，因此执行效率比较高。常见的库函数包括 strlen、printf、scanf、fopen、fclose 等。
- 个人解释：
    - 系统调用相对来说比较底层，是操作系统提供的接口，因此执行效率也较低，例如 open、read、write、close 等，而库函数调用则相对来说更加灵活，执行效率相对较高，库函数是对系统调用进行了一次封装，如果是涉及到访问操作系统服务和资源的任务，最后调用的依然是系统调用，例如在标准 C 库函数当中，`printf`函数最终会调用系统函数`write`，当然库函数可能不止调用一个系统调用。

系统调用类型

- 进程控制
- 文件管理
- 设备管理
- 信息维护
- 通信

操作系统的设计结构

- 单层
    - 单层结构将所有的操作系统功能都集成在一个大内核中，包括进程管理、内存管理、文件系统、设备驱动等。
    - 单层结构的优点是执行效率高，因为所有的操作系统功能都在同一个内核中，没有进程切换和数据传输的开销。但是，单层结构的缺点也很明显，它的可靠性差，容易受到错误的影响，因为所有的功能都在同一个内核中，一个错误可能导致整个系统崩溃。
    - 单层结构通常用于嵌入式系统或者小型计算机系统。
- 多层
    - 将操作系统的不同功能层次划分为若干个层次，每个层次提供一些特定的功能，上层调用下层提供的接口来完成自己的功能。通过分层法，操作系统的功能被分散到不同的层次中，每层只需实现自己的特定功能，从而更好地实现了模块化设计和可维护性 。
- 微内核
    - 将内核的功能划分为尽可能小的模块，每个模块只提供一种基本服务，如进程管理、内存管理、文件系统等。这些模块之间通过最小化的接口进行通信，从而实现了内核的高度模块化和可扩展性。与传统的宏内核相比，微内核的设计可以使操作系统更加灵活、可靠和安全。但是，由于微内核需要频繁地进行模块间通信，因此它的性能可能会受到一定的影响。
    - 微内核代表：macOS、WindowsNT
    - 宏内核代表：Unix、Linux
- 模块化设计

![image-20230612143816233](https://s2.loli.net/2023/06/12/NXBmGqiDa9s3Rr6.png)

进程（Process）定义

- 运行中的程序
- 资源分配的最小单位
- CPU 调度的一个单位（**CPU 调度的最小单位是线程 Thread**）
- 特征：
    - 动态性
    - 并发性
    - 独立性
    - 异步性
    - 结构性


进程的状态

- 新建 new
    - 进程正在被创建
- 运行 running
    - 进程正在被执行
- 等待或被阻塞 waiting
    - 进程等待某个事件的发生（比如 I/O 完成或者收到信号）
- 就绪 ready
    - 进程等待分配处理器
- 终止 terminated
    - 进程完成执行

![image-20230612151854309](https://s2.loli.net/2023/06/12/Wpz3nMGkrVLSRgP.png)

进程与线程的比较

- 进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位。
- 线程有时称轻量级进程，进程中的一个运行实体，是一个CPU调度单位。
- 进程和线程的不同之处可从以下四个方面比较：
    - 调度：线程作为调度的基本单位，同进程中线程切换不引起进程，当不同进程的线程切换才引起进程切换；进程作为拥有资源的基本单位。（所以说进程是资源分配的最小单位）
    - 并发性：一个进程间的多个线程可并发。
    - 拥有资源：线程仅拥有隶属进程的资源；进程是拥有资源的独立单位。
    - 系统开销：进程大；线程小。
- 多进程和多线程
    - 多进程：电脑里同时开浏览器、QQ、微信......
    - 多线程：同一个浏览器开很多窗口，下载文件，播放音乐......

进程控制块 PCB

- PCB 的信息包括：
    - 进程状态：状态可包括新的、就绪、运行、等待、停止等。
    - 程序计数器：计数器表示进程要执行的下个指令的地址。
    - CPU 寄存器：根据计算机体系结构的不同，寄存器的数量和类型也不同。
    - CPU 调度信息：这类信息包括进程优先级、调度队列的指针和其他调度参数。
    - 内存管理信息：根据操作系统所使用的内存系统，这类信息包括基址和界限寄存器值、页表或段表。
    - 记账信息：这类信息包括 CPU 时间、实际使用时间、时间界限、记账数据、作业或者进程数量等。
    - I/O 状态信息：这类信息包括分配给进程的 I/O 设备列表、打开的文件列表等。简而言之，PCB 简单地作为这些信息地仓库，这些信息在进程与进程之间是不同的。

进程切换的过程

- 决定是否作上下文切换以及是否允许作切换
- 保存当前执行进程的上下文
- 使用进程调度算法，选择一处于就绪状态的进程
- 恢复进程上下文，将 CPU 控制权交到所选进程中

进程切换对 CPU 的影响

- 每次上下文切换都需要几十纳秒到数微妙的 CPU 时间，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间，是导致平均负载升高的一个重要因素。

进程调度

- 长期调度

    - 长期调度，又称为**作业调度**或**高级调度**，这种调度将已进入系统并处于后备状态的作业按某种算法选择一个或一批，为其建立进程，并进入主机，当该作业执行完毕时，还负责回收系统资源。
    - 在**批处理系统**中，需要有作业调度的过程，以便将它们分批地装入内存，在分时系统和实时系统中，通常不需要长期调度。它的频率比较低，主要用来控制内存中进程的数量。

- 中期调度

    - 中期调度，又称为**交换调度**。
    - 它的核心思想是能将进程从内存或从CPU竞争中移出，从而降低多道程序设计的程度，之后进程能被重新调入内存，并从中断处继续执行，这种交换的操作可以调整进程在内存中的存在数量和时机。
    - 其主要任务是按照给定的原则和策略，将处于外存交换区中的就绪状态或等待状态的进程调入内存，或把处于内存就绪状态或内存等待状态的进程交换到外存交换区——即**换入换出**。

- 短期调度

    -  短期调度，又称为**进程调度**、低级调度或微观调度。
    - 这也是通常所说的调度，一般情况下使用最多的就是短期调度。
    - 它的主要任务是按照某种策略和算法将CPU分配给一个处于就绪状态的进程，分为**抢占式**和**非抢占式**。

进程创建

- 新进程的创建，首先在内存中为新进程创建一个 task_struct 结构，然后将父进程的 task_struct 内容复制其中，再修改部分数据。分配新的内核堆栈、新的 PID、再将 task_struct 这个 node 添加到链表中。所谓创建，实际上是“复制”。子进程刚开始，内核并没有为它分配物理内存，而是以只读的方式共享父进程内存，**只有当子进程写时，才复制。**

- `fork`函数
    - fork函数时调用一次，返回两次。在父进程和子进程中各调用一次。子进程中返回值为0，父进程中返回值为子进程的PID。程序员可以根据返回值的不同让父进程和子进程执行不同的代码。![image-20230612181009067](https://s2.loli.net/2023/06/12/7tXRn9uqeS8fDLb.png)
    - 当在父进程中，`fork()`的返回值是它的子进程的 PID 号
    - 当在子进程中，`fork()`的返回值是0
    - 如果出现错误，`fork()`的返回值是一个负值
    - 子进程与父进程的执行顺序是不确定的，所以运行同一个程序，每次的运行结果可能不相同
    - `wait(NULL)`的作用是在父进程中阻塞父进程直到子进程运行结束，回收资源
- `exec`函数
    - 由于使用`fork`函数创建的子进程与父进程可以说是一模一样的，但是为了在子进程中运行新的代码段或程序，就可以使用`exec`函数，当进程调用一种`exec`函数时，该进程的用户空间代码和数据完全被新程序替换，即当前进程剩下的程序代码便不再执行。调用`exec`并不创建新进程，所以调用`exec`前后该进程的 id 并未改变。当函数调用失败时，返回值为-1，调用成功则无返回值

进程通信

- 消息传递
    - 消息传递对于交换较少数量的数据很有用，因为不需要避免冲突。对于计算机间的通信，消息传递也比共享内存更易于实现。通常用系统调用来实现，因此需要更多的内核介入的时间消耗。
- 共享内存
    - 共享内存允许以最快的速度进行方便的通信，在计算机中它可以达到内存的速度。仅在建立共享内存区域时需要系统调用，一旦建立了共享内存，所有的访问都被处理为常规的内存访问，不需要来自内核的帮助。
- 个人理解（关于消息传递和共享内存）
    - 消息传递
        - 消息传递就好像是每个进程把消息放在自己家门口，并且写上收件人（进程），等着其他进程过来领
        - 内存共享就好像有一间公共房间专门用来交换信息，所有进程都把想要传递的信息放在这间房间里
- 如何进行内存共享
    - System V 共享内存
        - 允许多个进程共享同一块物理内存
        - 直接将共享的内存页面通过链接，映射到需要通信的进程各自的虚拟地址空间
        - 进而使得多个进程可以直接访问同一个物理内存页面
    - POSIX
        - 使用POSIX API，创建共享内存段。共享内存让一段内存可供多个进程访问。用特殊的系统调用（即对 UNIX 内核的请求）分配和释放内存并设置权限；通过一般的读写操作读写内存段中的数据。
        - 共享内存并不是从某一进程拥有的内存中划分出来的；进程的内存总是私有的。共享内存是从系统的空闲内存池中分配的，希望访问它的每个进程连接它。这个连接过程称为映射，它给共享内存段分配每个进程的地址空间中的本地地址。

并发与并行

- 并发和并行是两个不同的概念。并发是指多个任务在同一时间段内交替执行，并共享计算资源，注重任务的调度和资源管理。而并行是指多个任务同时进行，利用多个处理单元或计算资源，并独立进行，注重任务的分割和执行 。
- 简单来说，并发是一种现象，之所以能有这种现象的存在，和CPU的多少无关，而是和进程调度以及上下文切换有关的。可以将并发视为一种更高级的概念，而并行是并发的一种特定实现方式。

线程

- 线程是调度和分派的基本单位
- 进程 = 资源 + 指令执行序列
- 线程是 CPU 使用/调度的基本单元
- 由线程ID、程序计数器、寄存器集合和栈组成
- 与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开文件和信号
- 共享的内容：
    - 代码段
    - 数据段
    - 其他操作系统资源（如打开文件和信号）
- 不共享的内容：
    - 线程 ID
    - 寄存器组的值
    - 线程的栈
    - 错误返回码
    - 线程的优先级
    - 线程的信号屏蔽码
- 多线程的优势
    - 高响应度
    - 经济
    - 资源共享
    - 多处理器体系结构的应用
- 用户级线程
    - 对设置了用户级线程的系统，调度仍以进程为基本单位
    - 优点
        - 线程切换不需要转换到内核空间，节省开销
        - 调度算法可以是进程专用的。不同进程根据自身情况选择调度算法
        - 用户级线程的实现与操作系统平台无关
    - 缺点
        - 系统调用的阻塞问题：线程执行系统调用，引起进程阻塞，进而进程内的所有线程都被阻塞（一颗老鼠屎坏了一锅粥）
        - 不能充分利用多处理机多重处理的优点，内核每次分配给一个进程一个CPU，则该进程中只有一个线程能执行，其它线程必须等待
- 核心级线程
    - 优点
        - 在多处理机系统中，内核能够同时调度一个进程中的多个线程
        - 如果进程中的一个线程被阻塞了，内核可以调度该进程中的其他线程
        - 内核支持的线程具有很小的数据结构和堆栈，切换代价比进程小
        - 内核本身也可以设计多线程技术，提高系统给的执行速度和效率
    - 为了充分使用多核的特点，应使用核心级线程
- 多用户模型中的不同类型
    - 多（用户级线程）对一（核心级线程）模型
        - 多个用户级线程映射到同一个核心级线程，但是如果某一个用户级线程阻塞，整个进程都会被阻塞
    - 一（用户级线程）对一（核心级线程）模型
        - 将每个用户级线程映射到每一个不同的核心级线程，并发能力强，但是创建线程开销极大，影响应用性能
    - 多（用户级线程）对多（级线程）模型
        - 将 n 个用户级线程映射到 m 个核心级线程，其中 n >= m，是多对一模型与一对一模型的一种折中模型
- 线程库
    - 线程库为程序员提供创建和管理线程的 API。
    - 主要有两种方法来实现线程库。
        - 第一种方法是在用户空间中提供一个没有内核支持的库，此库的所有代码和数据结构都存在于用户空间中。调用库中的一个函数只是导致了用户空间中的一个本地函数调用，而不是系统调用。
        - 第二个方法是执行一个由操作系统直接支持的内核级的库。此时，库的代码和数据结构存在于内核空间中。调用库中的一个API函数通常会导致对内核的系统调用。
        - 类似于前面进程当中的系统调用与库函数

CPU 调度

- 周转时间 = 等待时间 + 执行时间
- **响应比 = 周转时间 / 执行时间**（一定要注意是周转时间/执行时间）
- 甘特图画法如下（就是类似于这样的图就是甘特图）
- ![image-20230612201025848](https://s2.loli.net/2023/06/12/7pSRTl6OPrDc5jq.png)
- 不同的 CPU 调度算法
    - FCFS（First Come First Served）先来先服务
        - 调度的顺序就是任务到达就绪队列的顺序
        - 特点
            - 非抢占，公平
            - 短作业等待时间长
            - 不适合交互系统
    - SJF（Shortest Job First）短作业优先
        - 顾名思义，最短的作业先执行，如果两个作业执行时间相同，那么采用 FCFS
        - SJF 可以保证最小的平均等待时间（在非抢占时的情况下）
        - 缺点
            - 对长作业不利（饿死）
            - 估计不准
            - 未考虑紧迫程度
    - SRTF（Shortest Remaining Time First）最短剩余时间优先
        - 抢占式的 SJF，也就是 SRTF
        - 如果一个新进程具有更短的CPU区间：
            - 非抢占SJF算法会允许当前运行的进程先完成其CPU区间
            - 抢占SJF算法可抢占当前运行的进程
    - Priority 优先级调度
        - 批处理
        - 如果两个进程优先级相同，则采用 FCFS
        - 缺点
            - 容易导致饥饿状态，即低优先级的作业可能一直无法执行
            - 老化，随着时间的推移，进程的优先权逐渐提高
    - RR（Round Robin）轮转法
        - 交互式
        - 轮转法是专门为分时系统设计的，每个进程获得一小片CPU时间量，通常为10-100ms。
        - 时间片结束后，进程被抢占并放入到就绪队列的最后重新参加调度。
        - 如果就绪队列中有n个进程，具有时间片为q，则每个进程会得到1/n的CPU时间，每个长度不超过q时间单元。每个进程必须等待CPU的时间不会超过（n－1）q个时间单元，直到它的下一个时间片为止。
        - 性能依赖于时间片的大小：
            - 如果时间片非常大（无限），那么轮转法策略与FCFS策略一样。
            - 如果时间片很小，那么轮转法称处理器共享，（从理论上来说）n个进程对于用户都有它自己的处理器，速度为真正处理器速度的1/n。
        - RR 策略的平均等待时间通常比较长，但是响应度高。
        - 优点
            - 定时有响应，等待时间较短
        - 缺点
            - 上下文切换次数过多
    - 多级队列
        - 根据进程的属性（内存、优先级和类型）将就绪队列分成相对独立的队列：前台（或交互式）后台（或批处理）。
        - 每个队列有自己的调度算法：前台，RR；后台，FCFS。
        - 队列之间必须有调度：通常采用固定优先权可抢占调度来实现。
        - 另一种可能是在队列之间划分时间片。每个队列都有一定的CPU时间，这可用于调度队列内的不同进程。80%给前台，20%给后台。
        - 存在问题
            - 无法区分 I/O Bound，CPU Bound
            - 也可能导致一定饥饿现象
    - 多级反馈队列
        - 主要思想：
            - 根据不同CPU区间的特点以区分进程。
            - 如果进程使用过多CPU时间，那么它会被转移到更低优先级队列
            - 在较低优先级队列中等待时间过长的进程被转移到更高优先级队列

实际上，只要有资源就有调度问题

调度的根本原因：请求数量大于资源数量

并发、虚拟、调度是操作系统中的核心技术

进程同步

- 并发进程之间的关系
    - 进程互斥
        - 多个进程不能同时使用同一资源，某个进程使用该资源时，其他进程必须等待
    - 进程同步
        - 多个进程的调用存在时序关系，某些进程执行必须先于另一些进程
- 并发进程可能会出现数据不同步的问题
- 竞争条件
    - 和时间有关的共享数据语义错误
    - 多个进程并发访问和操作同一（共享）数据，且执行结果和访问发生的特定顺序有关
    - 三重含义：竞争条件是这样一种情形
        - 多个进程并发访问和操作共享数据
        - 和时间有关就是和调度顺序有关
        - 这样的错误非常难调试
- 临界区
    - 不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。临界区是每个进程中访问临界资源的那段程序。
    - 不是所有共享资源都需要放到临界区内。
    - 一个进程可以有多个临界区。
    - 临界区访问原则：
        - 每次只允许一个进程进入临界区，进入后不允许其他进程进入。
    - 解决临界区问题的三个条件
        - 互斥
        - 前进
        - 有限等待
    - 解决临界区问题
        - Peterson 算法
            - 谦让的算法，但是无法解决同步问题
            - 如果一个进程不在临界区，那么另外一个进程也不一定在临界区
        - PV 信号量
            - 由 P 操作和 V 操作组成，也称 P 操作原语和 V 操作原语
            - 如果信号量为正数表示的是当前空闲的可供调用的资源数，如果为负数表示的是当前等待的进程的数量
- 临界资源
    - 一次仅允许一个进程访问的共享资源
    - 不是所有共享资源都需要放到临界区内

死锁

- 定义：
    - 多个进程因循环等待资源而造成无法执行的现象。（相当于是进了个死循环了）
- 死锁会造成进程无法执行
- 死锁会造成系统资源的极大浪费

- 在多道程序环境下，多个进程可能存在竞争一定数量的资源
- 某个进程申请资源，如果这时资源不可用，那么该进程进入等待状态
- 不是所有资源都会造成死锁
    - 比如只读资源，不会造成进程等待
    - 打印机一次只能让一个进程访问，就有可能造成死锁
- 死锁的必要条件是资源互斥访问
- 如果资源分配图没有环就不会造成死锁，但是有环也不一定会造成死锁
- 所有进程都在等待其他进程释放资源，导致所有进程都阻塞，导致死锁
- 死锁预防
    - 破坏发生死锁的四个条件之一
        - 四个条件分别是
            - 互斥
            - 占有并等待
            - 非抢占
            - 循环等待
- 死锁避免
    - 保证系统始终处于安全状态
    - **银行家算法**
        - 时间复杂度为 O(mn<sup>2</sup>)，其中 m 是资源种类，n 是进程数量
- 死锁检测
    - 同样采用银行家算法，如果 FInish[i] 为 true 就代表处于安全状态，如果 Finish[i] 为 false 就来判断系统是否处于死锁状态

内存

- 内存分配机制
    - 连续区内存分配
    - 非连续区内存分配
        - 分页
        - 分段

- 内存的根本目的
    - 把程序放在内存里执行
- 重定位
    - 操作系统认为：一个用户程序可以访问的内存空间是逻辑地址空间（虚拟地址），物理内存对应的地址空间是物理地址空间
    - 最合适重定位的时机：运行时
- MMU（存储管理单元）
    - 将虚拟地址在送往总线之前转换为物理地址
- 动态加载
    - 进程只有在被真正调用的时候才被装入内存，节省内存空间的使用
    - 所有子程序都以可重定位的形式保存在磁盘上
    - 不需要操作系统提供特殊支持
- 动态链接
    - 进程即将用到的代码段，不被预先连接到程序，只有到真正被调用的时刻才连接
    - 需要系统提供“动态连接库”的支持
    - 比如 Linux 中的 .so 文件，Windows 中的 .dll 文件
- 静态链接
    - 在编译时将程序中使用到的库文件的代码复制到可执行文件中，生成一个完整的可执行文件。这样生成的可执行文件比较大，但是运行时不需要依赖外部的库文件，因此可以在没有安装相关库文件的系统上运行。静态链接的缺点是浪费存储空间，同时如果使用的库文件更新了，需要重新编译程序
    - 就比如 C 语言中的`include`
- 内存如何管理：连续内存分配最直观
- 分段
    - 会造成内存碎片
    - 页表很好解决了外部碎片问题
- 段页结合
    - 让段面向用户，让页面向硬件
    - 在段页式存储管理中，逻辑地址由段号和页号组成，段号用于定位段表，页号用于定位页表，段表和页表的组合可以确定一个物理地址。这样，段页式存储管理既能够提供段式存储管理的灵活性，又能够提供页式存储管理的高效性。
    - 优点
        - 符合程序员习惯，并可高效利用内存
    - 缺点
        - 复杂，访问一次地址需要查表好多次
- First fit、Best fit、Worst fit
    - First fit
        - 找出第一个能满足的空闲块
    - Best fit
        - 找出剩余空闲块中最小的空闲块（但是也得满足大小要求）
    - Worst fit
        - 找出剩余空闲块中最大的空闲块（但是也得满足大小要求）
- 页表很大怎么办？
    - 层次页表/多级页表
    - 哈希页表
    - 反向页表
    - TLB（快表）得以发挥作用的原因
        - TLB命中时效率会很高，未命中效率会降低，平均后仍表现良好

虚拟内存

**上课时我们用 MIN = OPT**

- 为什么要实现虚拟内存？
    - 分段、分页是操作系统管理内存的两种主要方式
    - 虚拟内存是实现分段与分页的关键核心
    - 没有换入换出，虚拟地址就实现不了
- 只有浮现在内存芯片外地址总线上的地址才是物理地址
- 优点：
    - 地址空间>物理内存
        - 用户可以编写比内存更大的程序
    - 部分程序放入物理内存
        - 内存中可以放更多的进程
        - 将需要的部分放入内存，有些用不到的部分从来不放入内存，内存利用率高
    - 程序开始执行，响应时间更快
- 局部性原理
    - 时间局部性
    - 空间局部性
- 页面淘汰（置换）
    - FIFO（先进先出）
    - LRU（最近最久未使用）
    - OPT（MIN）（最远将要使用）
    - CLOCK（二次机会算法）（近似 LRU 算法）
- 缺页次数
    - 就是把页从外存调到内存的次数
- 却也中断率
    - 缺页次数/总的内存访问次数（就是总的序列长度）
- 几个现象
    - 抖动
    - CPU 利用率急剧下降的原因
        - 系统内进程增多
        - 每个进程的缺页率增大
        - 缺页率增大到一定程度，进程总等待调页完成
        - 调页要启动磁盘
        - 大家都等着
        - CPU利用率降低
        - 进程进一步增多，缺页率更大 …







​    

