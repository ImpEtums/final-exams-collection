# 软件测试与质量保证期末复习笔记

## 软件测试基本概念

软件缺陷：

- 从产品内部来看，是软件产品开发或维护过程中所存在的错误、毛病等各种问题。
- 从外部来看，是系统所需要实现的某种功能的失效或违背。

软件缺陷的表现：

- 软件没有实现产品说明书中描述的功能（该实现的没有实现）
    - 比如一个计算器本来应该实现数字的加减乘除，但是在按了加号键之后并没有反应
- 软件实现了产品说明书中描述的不应有的功能（不该实现的实现了）
    - 比如学生管理系统规定只能老师修改学生的成绩，但是结果学生同样可以修改自己的成绩
- 软件功能超出了产品说明书中指明的范围（不该实现的实现了）
    - 比如学生本来只能查看自己的成绩，但是实际上也能查看到别的同学的成绩（同一种功能但是权限扩大了）
- 软件未达到产品说明书中虽未指出但应当达到的目标
    - 比如说学生成绩管理系统，学生的成绩应当是0——100之间的数字，但是结果提交字符串照样能够提交
- 软件测试人员认为软件难以理解、不易使用，运行时间过长，或者最终用户认为该软件使用效果不良
    - 比如说学生制作的一个系统，老师认为 UI 设计过于简陋，软件交互不友好

软件测试的定义：

- 软件测试是发现并指出软件中存在缺陷的过程。
- 这个过程指明和标注问题存在的正确位置，详细记录导致问题出现的操作步骤，及时存储当时的错误状态。
    - 便于测试后问题能够准确再现。

软件缺陷的根本原因：软件规模和复杂性的增长。

解决软件缺陷问题最有效途径：软件测试。

软件 = 程序 + 数据 + 文档

测试对象：包含建模、需求、设计等阶段所产生的大量输出制品以及程序代码。

**软件测试开始阶段：需求阶段。**

软件缺陷产生的原因：

- 非技术原因（开发人员没理解好要做什么）
    - 需求理解不到位
    - 需求变化
    - 需求不一致
    - 需求不完整
- 技术原因（开发人员知道该做什么，但是没做好）
    - 架构有瑕疵
    - 算法有问题
    - 编码错误

**软件测试的目的：尽可能早的发现缺陷。**

软件测试模型：

- V 模型（整个流程呈现 V 字型）![image-20230602205638778](https://s2.loli.net/2023/06/02/dEkh1uHrYT3DnZb.png)

软件质量模型：

![image-20230602205957909](https://s2.loli.net/2023/06/02/CtwTR71hEP6Dygl.png)

缺陷：任何违背质量的问题。

软件测试的分类：

![image-20230602210518768](https://s2.loli.net/2023/06/02/EgBbVJe3IhfsWn6.png)

- 测试是否执行程序
    - 静态测试
        - 代码静态测试：主要测试代码是否符合相应的标准和规范
            - 静态代码检查工具：
                - CheckStyle
                - PMD
                - FindBug
                - SourceMonitor
                - JTest
                - P3C
        - 界面静态测试：主要测试软件的实际界面与需求中的说明是否相符
        - 文档静态测试：主要测试用户手册和需求说明是否真正符合用户的实际需求
    - 动态测试（指通过运行被测程序，检查运行结果与预期结果的差异，来分析软件质量，如功能性、效率、可靠性的过程）
        - 步骤1:设计测试用例
        - 步骤2:搭建测试环境
        - 步骤3:编写测试程序（脚本）
        - 步骤4:执行测试
        - 步骤5:分析测试结果

- 测试是否针对系统的内部结构和具体实现算法来完成测试
    - 黑盒测试
    - 白盒测试
- 从测试的对象和范围
    - 单元测试
    - 集成测试
    - 系统测试
    - 验收测试
    - 回归测试
    - 灰度测试
    - 文档测试
- 测试的目的
    - 性能测试
    - 安全性测试
    - 兼容性测试
    - 安装测试
    - 流量测试
    - 电量测试
    - 弱网络测试
- 测试方式
    - 手动测试
    - 自动化测试

软件测试的原则：

- 尽早地和不断地进行软件测试（从需求阶段就开始软件测试）
- 程序员应避免检查自己的程序
- 完全测试程序是不可能的
- 软件测试是有风险的行为
- 在设计测试用例时，应当包括合理的输入条件和不合理的输入条件
- 充分注意测试中的群集现象
- 严格执行测试计划，排除测试的随意性
- 应当对每一个测试结果做全面检查
- 妥善保管测试文档等
- 并非所有软件缺陷都能修复
- bug 的80%原则

软件测试的常见误区

- 误区1:调试和测试是一样的❌
- 误区2:软件测试对象就是程序❌
- 误区3:软件测试是测试人员的事情，与开发人员无关❌
- 误区4:好的软件质量是通过测试得到的❌
- 误区5:把不合格的开发人员安排做测试❌
- 误区6:关注于测试的执行而忽略测试的设计❌
- 误区7:测试自动化是万能的❌
- 误区8:测试是为了证明软件的正确性❌

## 白盒测试（important）

通过分析被测单元的内部程序结构来设计测试用例。

白盒测试又叫做结构测试，逻辑驱动测试或基于程序本身的测试。

**白盒测试方法：**

- 逻辑覆盖测试
    - 语句覆盖
        - 设计若干条测试用例，使程序中每条可执行语句至少执行一次。
    - 判定覆盖（分支覆盖）
        - 设计测试用例，使程序中的每个逻辑判断的取真和取假的分支至少经历一次。
        - 判定覆盖是最弱的覆盖标准。
    - 条件覆盖
        - 设计若干测试用例，使程序的每个判定中的每个条件的可能取值至少满足一次。
    - 判定-条件覆盖
        - 使判定中每个条件的可能取值至少满足一次，并且使每个判定分支至少执行一次。
        - 判定-条件覆盖能同时满足判定、条件两种覆盖标准。
    - 条件组合覆盖
        - 设计用例，使得每个判断表达式中条件的各种可能组合都至少出现一次。
    - 路径覆盖
        - 设置足够多的测试用例，覆盖程序中的每条可能路径。
- 路径分析测试

**条件覆盖和判定覆盖的区别：**

假设有一个条件式：a > 1 or b > 1。

判定覆盖：只需要考虑式子整体的覆盖条件，式子整体为 true 或者 false。

条件覆盖：条件式中每个条件都需要考虑，包括(a > 1)的真假和(b > 1)的真假。

判定-条件覆盖则是既要满足判定覆盖也有满足条件覆盖。

**判定-条件覆盖和条件组合覆盖的区别**

```cpp
#include <iostream>
using namespace std;
int main()
{
  int a, b;
  cin >> a >> b;
  if (a < 0 and b < 0)
    cout << a + b << endl;
  return 0;
}
```

上面有一个最简单的 if 语句结构。

我们先来设计一组最简单的满足判定-条件覆盖的测试样例。

| a    | b    | a<0   | b<0   | a<0 and b<0 |
| ---- | ---- | ----- | ----- | ----------- |
| -1   | -1   | false | false | false       |
| 1    | 1    | true  | true  | true        |

接下来我们来设计一组满足条件组合覆盖的测试样例。

| a    | b    | a<0   | b<0   | a<o and b<0 |
| ---- | ---- | ----- | ----- | ----------- |
| -1   | -1   | false | false | false       |
| -1   | 1    | false | true  | false       |
| 1    | -1   | true  | false | false       |
| 1    | 1    | true  | true  | true        |

由上面的测试样例我们可以知道，条件组合覆盖最重要的在于**覆盖**两个字，要求的是测试样例中要出现所有可能的**组合**情况，即：

| true  | true  |
| ----- | ----- |
| true  | false |
| false | true  |
| false | false |

下方是一道对路径覆盖的测试题。

![image-20230603200522136](https://s2.loli.net/2023/06/03/LqtCEsAK4UGNmPl.png)

流程图如下。

![image-20230603200536712](https://s2.loli.net/2023/06/03/d97j1LVt2c5IXem.png)

**控制流图**

由节点和控制流线组成的，描述程序控制结构的图形叫做控制流图。

控制流图是退化的程序流程图，图中每个处理都退化成一个结点，流线变成连接不同结点的有向弧。

控制流图将程序流程图中结构化构件改用一般有向图的形式表示。

基本控制流图如下：![image-20230603201855973](https://s2.loli.net/2023/06/03/iWQHDrNJ8f3SzhP.png)

区域：由边和节点封闭起来的区域

计算区域：不要忘记区域外的部分

圈复杂度：是一种描述程序内部逻辑复杂度的标准，代码逻辑复杂度的度量，给出了程序独立程序集中的独立路径条数。

复杂度越高，出错的概率越大。

**V(G) = 区域数量（由节点、连线包围的区域，包括图形外部区域）**

**V(G) = 连线数量 - 节点数量 + 2**

**V(G) = 分支节点 + 1**

分支节点也叫做判定节点，包括：

- if 语句
- while 语句
- for 语句
- case 语句
- catch 语句
- and or 布尔操作
- 三元运算符

针对下面这张图计算出它的圈复杂度。

![image-20230603204608280](https://s2.loli.net/2023/06/03/6X1fomV5WcSveQM.png)

可以看到总共有四个区域，所以圈复杂度为4。

可以看到边的数量为11，节点数量为9，所以圈复杂度为4。

可以看到分支节点数量为3，分别是（1，23，6），所以圈复杂度为4。

**基本（独立）路径测试**

在程序控制流图的基础上，通过分析控制流图的环路复杂性，导出可执行的独立路径集合，从而设计相应的测试用例。

1、一句代码绘制出流程图/控制流图。

2、确定流图的圈复杂度。

3、确定独立路径的基本集合。

4、设计测试用例覆盖每条基本路径。

名词解释：

- 独立路径：是指和其他路径相比，至少引入一个新处理语句或一个新判定的程序通路，它必须至少包含一条在本次定义路径之前不能用过的边。
- 基本集：由独立路径构成的集合。
- 由基本集到处的测试用例，保证每个可执行语句至少执行一次。
- 基本集合并不唯一。

**注意：如果一条判定语句有两个或者多个判断条件，那么这几个判断条件要分开来写。**

```cpp
void DoWork (int x,int y,int z)
{
1   int k=0,  j=0;
2   if ( (x>3)&&(z<10) )
3  {
4       k=x*y-1;
5          j=sqrt(k);
6    }
7     if((x==4)||(y>5))
8    j=x*y+10;
9     j=j%3;
10 }
说明：程序段中每行开头的数字（1~10）是对每条语句的编号
```

控制流图如下：![image-20230603205839908](https://s2.loli.net/2023/06/03/1ATa9u8rcHfboBw.png)

白盒测试：

- 内部的变量状态、逻辑结构、运行路径等
- 检验程序中的每条通路是否按照预定的要求工作
- 检查程序内部动作或者运行是否符合设计规格要求
- 所有内部成分是否按照规定正常进行

如何衡量测试效果？

- 覆盖路是测试覆盖质量的一个重要指标，通过测试覆盖率的统计，可以帮助改善测试用例，提高测试质量。
- 覆盖率检查的标准有逻辑覆盖、循环覆盖和基本路径覆盖。
- 需要通过同居对软件测试覆盖结果进行考察。

## 黑盒测试

把被测程序视为一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下进行的测试。

![image-20230603211728143](https://s2.loli.net/2023/06/03/r5Zdvm7oMeaihGV.png)

黑盒测试又叫功能测试，数据驱动测试或者基于规格说明。

重点：

- 等价类划分法
- 边界值法
- 判定表法
- 错误推测法
- 方法的选择

等价类：指某个输入域的子集合。在该集合中，各个输入数据对于揭露程序中的错误都是等效的，他们具有等价特性，即每一类的代表性数据在测试中的作用都等价于这一类中的其他数据。

等价类划分法：

- 定义：是把所有可能的输入数据，即程序的输入域划分为若干部分（子集），然后从每一个子集中选择少数具有代表性的数据作为测试用例。
- 意义：
    - 完备性——整个输入域提供一种形式的完备性。
    - 无冗余性——若不相交则可保证一种形式的无冗余性。
- 如何划分：
    - 先从程序的规格说明书中找出各个输入条件，再为每个输入条件划分两个或者多个等价类，形成若干个互不相交的子集。
    - 也可以针对输出数据来分析。
- 有效等价类：
    - 是指由完全满足程序规格说明、有意义的、合理的输入数据所组成的集合。利用有效等价类，能够检验程序是否实现了规格说明中预先规定的功能和性能。
- 无效等价类：
    - 与有效等价类相反，即不满足程序输入要求或无效的输入数据所构成的集合，利用无效等价类，可以鉴别程序异常处理的情况，检查被测对象的功能和性能的实现是否有不符合规格说明要求的地方。
- 划分依据：
    - 按照区间划分，在输入条件规定了取值范围或值的个数的情况下，可以确定一个有效等价类和两个无效等价类。（比如说假设确定了有效值的范围是1——10，那么有效等价类就是在这范围内的数，无效等价类就是小于1，或者大于10这两个无效等价类。）
    - 按照数值划分，在规定了一组输入数据（假设包括 n 个输入值），并且程序要对每一个输入值分别进行处理的情况下，可确定 n 个有效等价类（每个值确定一个有效等价类）和一个无效等价类（所有不允许的输入值的集合）。
    - 按照数值集合划分，在输入条件规定了输入值的集合或规定了“必须如何”的条件下，可以确定一个有效等价类和一个无效等价类（该集合有效值之外）。
    - 按照限制条件或规则划分，在规定了输入数据必须遵守的规则或限制条件的情况下，可以确定一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。
- 步骤：
    - 确定等价类，列出等价类表，为每个人等价类规定唯一的编号。
    - 设计测试用例。
        - 设计一个新的测试用例，使它能够尽量覆盖尚未覆盖的有效等价类，重复这个步骤，直到所有的有效等价类均被测试用例所覆盖。
        - 设计一个新的测试用例，使它仅覆盖一个尚未覆盖的无效等价类，重复这一步骤，直到所有的无效等价类均被测试用例所覆盖。
        - 细分等价类，在确知已划分的等价类中各元素在程序中的处理方式不同的情况下，则应再将该等价类进一步划分为更小的等价类，并建立等价类表。

等价类分为**有效等价类**和**无效等价类**。

软件不仅要能接受合理的数据，也要能经受异常数据的考验。

经过正反的测试才能够确保软件具有更高的可靠性。

下面是一个等价类划分法的测试题。![image-20230603214854717](https://s2.loli.net/2023/06/03/tBc8esF5GajUEuL.png)

![image-20230603214905936](https://s2.loli.net/2023/06/03/BniUADC56pdLyMQ.png)

![image-20230603214918789](https://s2.loli.net/2023/06/03/KXyneQtrZfaNEFD.png)

等价类划分既要考虑有效等价类，也要考虑无效等价类，有效等价类可以验证需求规格说明书中预先规定的功能，而无效等价类可以验证不满足的功能。

等价类的划分是一个逐步优化与细化的过程，合理的划分可以免去遗漏软件缺陷的风险。

等价类测试分类：

- 标准等价类测试：不考虑无效数据值。
    - 测试用例使用每个等价类中的一个值。
- 健壮等价类测试：考虑无效等价类。
    - 对有效输入，测试用例从每个有效等价类中取一个值。
    - 对无效输入，一个测试用例有一个无效值，其他值均取有效值。

边界值分析法

- 定义：边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法，通常边界值分析法是作为对等价类划分法的补充，这种情况戏，其测试用例来自等价类的边界。
- 为什么使用边界值分析法：无数的测试实践表明，大量的故障往往发生在输入定义域或输出值域的边界上，而不是在其内部，因此，针对各种边界情况设计测试用例，通常会取得很好的测试效果。
- 如何使用边界值分析法设计测试用例？
    - 首先确定边界情况，通常输入或输出等价类的边界就是应该着重测试的边界情况。
    - 选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值。
- 选取测试用例的原则：
    - 如果输入条件规定了值的范围，则应取刚达到这个范围的边界值以及刚刚超过这个范围边界的值作为测试输入数据。
    - 如果输入条件规定了值的个数，则用最大个数、最小个数和比最大个数多一个、比最小个数少一个的数作为测试数据。
    - 如果程序的规格说明给出的输入域或输出域是有序集合（如有序表、顺序文件等），则应选取集合中的第一个和最后一个元素作为测试用例。
    - 如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例。
    - 分析程序规格说明，找出其他可能的边界条件。
    - 采用边界值分析测试的基本思想是：故障往往出现在输入变量的边界值附近，因此，边界值分析法利用输入变量的最小值 min、略大于最小值 min+、输入值域内的任意值 nom、略小于最大值 max- 和最大值 max 来设计测试用例。
    - 边界值分析法是基于可靠性理论中成为“单故障”的假设，即有两个或两个以上故障同时出现而导致软件失效的情况很少，也就是说，软件失效基本上是由单故障引起的，因此，在边界值分析法中获取测试用例的方法是：
        - （1）每次保留程序中一个变量，让其余的变量取正常值，被保留的变量依次取 min、min+、nom、max-、max。
        - （2）对程序中的每个变量重复（1）。

**判定表法**

判定表原理：又叫做决策表。

判定表法是分析和表达多逻辑条件下执行不同操作的工具。

在程序设计发展的初期，决策表被当作编写程序的辅助工具。

判定表的组成：

- 条件桩（列出问题的所有条件）
- 动作桩（列出可能采取的操作）
- 条件项（列出条件桩的取值）
- 动作项（列出条件项各种取值下应该采取的动作）

规则：

- 任何一个条件组合的特定取值及其相应要执行的操作被称为规则。
- 在判定表中贯穿条件项和动作项的一列就是规则。
- 判定表中列出多少组条件取值，也就有多少条规则，即条件项和动作项有多少列。

规则合并：

- 规则合并就是判定表的简化。
- 有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系，就可以将规则合并。

判定表建立步骤：

- 根据软件规格说明
    - 列出所有的条件桩和动作桩。
    - 确定规则的个数。（假设有 n 个条件，每个条件有两个取值0和1，则有2种规则）
    - 填入条件项。
    - 填入动作项，得到初始决策表。
    - 简化，合并相似规则（相同动作）。

判定表的优缺点：

优点：

- 能把复杂的问题按各种可能的情况一一列举出来。
- 简明而易于理解。
- 可避免遗漏。

缺点：

- 不能表达重复执行的动作，形如循环结构。
- 判定表不能很好地伸缩。（有 n 个条件的决策表就有 2^n 个规则。

解决方法：

- 代数简化表。
- 将大表分解为小表。

什么时候适合用判定表方法来设计测试用例：

- if-then-else 逻辑突出。
- 输入变量之间存在逻辑关系。
- 规格说明以判定表形式给出，或较容易转换为判定表。
- 条件的排列顺序不会也不应影响执行的操作。
- 规则的排列顺序不会也不应影响执行的操作。
- 如果某一规则的条件要执行多个操作，这些操作的执行顺序无关紧要。

两两组合方法：

- 绝大部份缺陷是在两个变量取值冲突的测试时候被发现的。
- 所以，测试所有的 Pairwise 就基本满足质量要求。

![image-20230604000644051](https://s2.loli.net/2023/06/04/MVD4RawpJjCeu9m.png)

测试方法的选择策略：

- 根据程序的重要性和一旦发生故障将造成的损失来确定测试等级和测试重点。
- 用尽可能少的测试用例，发现尽可能多的程序错误，一次完整的软件测试过后，如果程序中遗留的错误过多并且严重，则表明该次测试是不足的，而测试不足则意味着让用户承担隐藏错误带来的危险，但测试过度又会带来资源的浪费，因此测试需要找到一个平衡点。
- 在任何情况下都必须采用**边界值分析法**，这种方法设计出的测试用例发现程序错误的能力最强。
- 必要时采用等价类划分法补充测试用例。
- 采用错误推断法再追加测试用例。
- 对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度，如果没有达到要求的覆盖标准，则应当再补充更多的测试用例。
- 如果程序的功能说明中含有输入条件的组合情况，则应一开始就选用判定表法或因果图法。

## 软件测试的技术

测试的不同阶段：

- 需求评审
- 设计评审
- 单元测试
- 集成测试
- 系统测试
    - 是对整个系统的测试，将硬件、软件、操作人员看作一个整体，检验他是否有不符合系统说明书的地方。
- 验收测试

## 单元测试

单元测试：

- 定义：单元测试是对软件基本组成单元进行的测试。
- 时机：一般在代码完成后由开发人员完成，QA 人员辅助。
- 概念：模块、组件、单元
- 为什么要进行单元测试？
    - 尽早发现错误
        - 错误发现越早，成本越低
        - 发现问题比较容易
        - 修正问题比较容易
    - 检查代码是否符合设计和规范，有利于将来代码的维护
- 静态测试
- 动态测试
    - 步骤1:设计测试用例
    - 步骤2:搭建测试环境
    - 步骤3:编写测试程序（脚本）
    - 步骤4:执行测试
    - 步骤5:分析测试结果

边界条件特点：

- 一致性
    - 值是否和预期的一致
- 有序性
    - 值是否如应该的那样，是有序还是无序
- 区间性
    - 值是否位于合理的最小值和最大值之内
- 引用、耦合性
    - 代码是否利用了一些不在代码本身控制范围之内的外部资源
- 存在性
    - 值是否存在
- 基数性
    - 是否恰好有足够的值
- 时间性

## 集成测试

集成测试：一种旨在暴露单元接口之间、组件/系统间交互或协同工作时所存在的缺陷的测试。

不同层次的集成测试：

- 软件单元与软件单元的集成测试
- 软件子系统和子系统的集成测试
- 软件系统和第三方系统的集成测试
- 软件系统和硬件的集成测试

集成测试的模式：

- 非渐增式测试模式
    - 先分别测试每个模块，再把所有模块按设计要求放在一起组成所要的程序，如大棒模式
- 渐增式测试模式
    - 把下一个要测试的模块同已经测试好的模块结合起来进行测试，测试完以后再把下一个已测试的模块结合进来测试

集成测试重在接口测试。

接口：

- 接口是为不同系统和功能之间实现分离或连接的口。
- 在计算机系统中，也可分为硬件接口和软件接口。
- 硬件接口常见的有 USB 口，耳机接口，HDMI 接口等。
- 软件接口常见的有 API 接口，也称为应用编程接口。

接口测试：

- 接口之间传递的参数是否一致（个数、属性、量纲）
- 全局变量引用是否一致
- 数据流一致性处理
- 缓冲区数据的处理

接口测试要点：

- 接口中所有的参数的不同类型的有效值都要被测试
- 参数的每个错误类型都要准备一个异常用例
    - 如缺省值、类型错误、范围错误、参数超过最大位数、无效值、参数的关联性查看等
- 把每个参数单独作为条件来进行测试，在进行多条件关联组合测试

**HTTP 工作原理**

接口测试需要模拟浏览器发送 Request 至服务器和服务器返回 Response 到浏览器的整个过程。

客户端主要的两个职能：

- （1）向服务器发送请求
- （2）接收服务器返回的报文并解释成友善的信息供我们阅读

HTTP 协议详细规定了客户端与服务器之间互相通讯的规则，他主要解决了两个问题：

- 如何定位资源（URL）
- 客户端与服务器之间如何进行信息传递（报文）

URL：统一资源定位符

URL 是用于指定信息位置的表示方法，他用来表示万维网上各种资源，使每一个资源在整个因特网的范围内具有唯一的标识符。

URL 的组成形式一般为：

| http://            | 主机                             | 端口                              | 路径           |
| ------------------ | -------------------------------- | --------------------------------- | -------------- |
| 表示使用 HTTP 协议 | 存放资源的主机域名或主机 IP 地址 | HTTP 的默认端口号是80，通常可省略 | 访问资源的路径 |

![image-20230604013310903](https://s2.loli.net/2023/06/04/uj9F3qk6AZUil8I.png)

报文

- 请求报文
    - 客户端向服务器发送请求时，会给服务器发送一个请求报文，请求报文包含请求的方法，如 URL、协议版本、请求头部和请求数据，URL只是标识资源的位置，而 HTTP 报文用来提交和获取资源，客户端发送的 HTTP 请求消息，包括请求行，请求头部、空行和请求体4个部分。
- 响应报文
    - 由4个部分组成，分别是：状态行、响应头部、空行、响应体

持续集成：持续集成是软件开发越来越普遍的一种优秀实践，即团队开发成员经常集成他们的工作，通常每天新完成的代码至少集成一次，也就意味着每天可能会发生多次集成。

如何做好持续集成？

- 维护单一的代码库
- 每人每天及时将自己的代码提交到产品代码主干上，代码版本管理会有多个分支，但主干只有一条，这样做可以确保最新的代码同步
- 应在产品运行的克隆环境上运行测试，尽量确保测试环境和产品运行环境的一致性
- 版本构建速度很快，1小时或者2小时
- 造成版本无法构建的缺陷要立刻修复，确保构建成功才能进行版本验证
- 每人能较容易地拿到最新的可执行版本，及时浏览团队实现的产品功能特性

CI 环境是支撑 CI 实施的基础设施。

持续集成系统的组成：

- 一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库
- 一个自动构建过程，由此可见，一个完整的构建系统必须包括
    - 自动编译、分发、部署和测试等
- 一个持续集成服务器，如 Jenkins 就是一个配置简单和使用方便的持续集成服务器。

持续集成的原则：

- 需要版本控制软件保障团队成员提交的代码不会导致集成失败。
- 开发人员必须及时向版本控制库中提交代码，也必须经常性地从版本控制库中更新代码到本地。
- 需要有专门的集成服务器来执行集成构建，根据项目的具体实际，集成构建可以被软件的修改来直接触发，也可以定时启动，如每半个小时构建一次。
- 必须保证构建的成功，如果构建失败，修复构建过程中的错误是优先级最高的工作，一旦修复，需要手动启动一次构建。

持续集成的内涵：

- 持续检查
- 持续构建
- 持续部署
- 持续验证、测试
- 持续集成环境
- 持续报告

持续集成的核心价值：

- 持续集成中的任何一个环节都是自动完成的，有利于减少重复过程以节省时间、成本等
- 任何时间点都能第一时间发现软件的集成问题，使随时发布可部署的软件成为了可能，做到持续集成，才能够做到持续交付
- 有利于软件本身的发展趋势，在需求不明确或频繁变更的情境中尤其重要，能够更好、更快地满足用户的需求
- 能帮助团队进行有效决策、提高开发产品的信心
- 尽早、尽快地进行集成，有助于今早发现 BUG，避免集成中大量 BUG 涌现，容易定位和修正 BUG，这样能够提高软件开发的质量和效率

## 非功能性测试

- 性能测试
- 安全性测试
- 容错性测试
- 可靠性测试
- 兼容性测试

## 性能测试

- 常见的性能问题
    - 资源耗尽（CPU 使用率达到100%）
    - 资源泄漏（内存泄漏，最终会导致资源耗尽）
    - 资源瓶颈（线程、GDI、DB连接等资源变得稀缺）
- 定义：
    - 为了发现系统性能问题或获取系统性能相关指标而进行的测试。
    - 一般在真实环境、特定负载条件下，通过工具模拟实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析来确定系统的性能状况。
- 性能测试需求
    - 用户对各项指标提出的明确需求，如果用户没有提出性能指标，则根据用户需求、测试设计人员的经验来设计各项测试指标。
- 主要的性能指标
    - 服务器的各项指标（CPU、内存占用率等）、后踢啊数据库的各项指标、网络流量、响应时间
- 性能需求应该具有可测试性
- 性能的具体指标
    - 数据传输的吞吐量
    - 数据处理效率
    - 数据请求的响应时间
    - 内存和 CPU 使用率
    - 连接时间、发送时间
    - 处理时间、页面下载时间
    - 第一次缓冲时间
    - 每秒（SSL）连接数
    - 每秒事物总数、每秒下载页面数
    - 每秒点击次数、每秒 HTTP 响应数
    - 每秒重试次数
- 性能测试目标
    - 获取系统性能某些指标数据
    - 为了验证系统是否达到用户提出的性能指标
    - 发现系统中存在的性能瓶颈，优化系统的性能
- 性能测试类型
    - 性能验证测试
        - 验证系统是否达到事先已定义的系统性能指标、能否满足系统的性能需求
    - 性能基准测试
        - 在系统标准配置下获得有关的性能指标数据，作为将来性能改进的基准线
    - 性能规划测试
        - 在多种特定的环境下，获得不同配置的系统的性能指标，从而决定在系统部署时采用什么样的软、硬件配置
    - 容量测试
        - 也可以看做性能测试的一种，因为系统的容量可以看做是系统性能指标之一
- 负载测试
    - 负载测试的目标是测试在一定负载情况下，系统的性能
    - 实际中，我们常从较小的负载开始，逐渐增加模拟用户的数量，观察不同负载下，系统的响应时间，所耗资源，直到超时或资源耗尽，这就是所说的负载测试
- 压力测试
    - 是模拟实际应用的软硬件环境及用户使用过程的系统负荷，长时间或超大负荷地运行测试软件，来测试被测系统的性能、可靠性、稳定性等
- 负载
    - 每次请求发送的数据量
    - 并发连接数
    - 思考时间，用户发出请求之间的间隔时间
    - 加载的循环次数或持续时间
    - 加载的方式或模式，如均匀加载、峰值交替加载等
- 性能测试的方法和技巧
    - 两种负载类型
        - “flat”测试
            - 对于一次给定的测试，应该取响应时间和吞吐量的平均值，精确地获取这些值的唯一方法是一次加载所有的用户，然后在预定的时间段内持续运行
        - ramp-up 测试
            - 用户是交错上升的（每几秒增加一些新用户）。ramp-up 测试不能产生精确和可重现的平均值，这是因为用户的增加是每次一部分，系统的负载在不断地变化。其优点是，可以看出随着系统负载的改变，测量值是如何改变的，据此选择要运行的 flat 测试的范围
    - 对于企业级的系统，性能测试的方法主要有
        - 基准测试
            - 关键是要获得一致的、可再现的结果
            - 将系统置于相同的高负载下，将请求之间间隔时间设为0，这样服务器会立即超载，并开始构建执行队列，如果请求（虚拟用户）数保持一致，基准测试的结果会非常精确，flat 运行是获得基准测试数据的理想模式
        - 性能规划测试
            - 性能规划类型的测试其目标是找出在特定的环境下，给定应用程序的性能可以达到何种程度
        - 渗透测试
            - 是一种比较简单的性能测试，所需时间较长，它使用固定数目的并发用户测试系统的总体健壮性，这些测试将会通过内存泄漏、增加的垃圾收集（GC）或系统的其他问题，显示因长时间运行而出现的任何性能降低
        - 峰谷测试
            - 兼有容量规划 ramp-up 测试和渗入测试的特征，目标是确定从高负载恢复、转为几乎空闲、然后再攀升到高负载、再降低的能力
- 性能测试基本过程
    - 确定性能测试需求
        - 要度量哪些指标
        - 会承受哪些负载
        - 确定关键业务
    - 根据测试需求，选择测试工具和开发相应的测试脚本
    - 建立性能测试负载模型
        - 确定虚拟用户数
        - 每次请求数据量
        - 思考时间
        - 加载方式
        - 持续加载时间
    - 执行性能测试
    - 分析测试
- 性能测试要点
    - 测试环境应尽量与产品运行环境保持一致，应单独运行尽量避免与其他软件同时使用
    - 录制脚本和手工编写脚本相结合
    - 重点在于前期数据的设计与后期的数据的分析
    - 设置数据池，实现变量加载
    - 采用复合交易测试方案，业务批量执行
    - 需要同时监控数据库服务器、Web 服务器以及网络资源等使用情况，以便对系统的性能做全面评估
    - 模拟用户数的递增
    - 合理设置交易之间时间间隔
    - 超时的设置，错误处理
    - 并发用户连续执行交易数的设置、设置并发点
    - 并发用户数量极限点
    - 尽量将执行负载测试的机器合理分布
    - 加压机器的 CPU 使用率也有必要监控
- 性能测试工具
    - 能模拟实际用户的操作行为，记录和回放多用户测试中的事物处理过程，自动生成相应的测试脚本
    - 能针对脚本进行修改，增加逻辑控制，完成参数化和数据关联
    - 可以设置不同的应用环境和场景，通过虚拟用户执行相应的测试脚本
    - 通过系统监控工具获得系统性能的相关指标的值

## 缺陷管理

缺陷：最终产品同用户的期望不一致

- 功能错误
- 功能遗漏
- 超出需求的部分
- 性能不符合要求

为了更好地分析缺陷，需要对缺陷在严重程度、优先级以及状态上加以区分。

- 缺陷严重程度
    - 衡量缺陷对客户满意度的影响程度（致命的、严重的、一般的、微小的）
- 缺陷优先级
    - 指缺陷被修复的紧急程度
- 缺陷状态

## Web 应用安全-SQL 注入攻击

SQL 注入攻击

- SQL 注入攻击一般是针对服务端的数据库
- 利用 Web 应用程序对用户输入数据的合法性没有判断或过滤不严，使得用户输入影响 SQL 查询语句的语法，从而实现非法操作，如绕过系统的身份验证、获取数据库中的数据及执行命令等
- 形成主要原因：
    - 程序没有细致的过滤用户输入的数据，致使非法数据侵入系统，并被 SQL 解释器执行。
- 危害：
    - 使得系统业务功能异常或者失效
    - 恶意的破坏，比如修改数据、删数据、删表等恶意破坏
    - 探查数据库类型，结构，获取数据库敏感数据，造成数据泄露
    - 修改数据库配置，控制服务器，进行恶意活动
- SQL 注入攻击的分类
    - 依据注入点类型分类
        - 数字类型的注入
        - 字符串类型的注入
        - 搜索型注入
    - 依据提交方式分类
        - GET 注入
        - POST 注入
        - COOKIE 注入
        - HTTP 注入
    - 依据获取信息的方式分类
        - 基于布尔的盲注
        - 基于时间的盲注
        - 基于报错的注入
        - 联合查询注入
        - 堆查询注入
- 防御 SQL 注入攻击
    - 使用预编译语句
    - 使用存储过程，将 SQL 语句定义在数据库中
    - 限制数据类型，进行数据过滤
        - 对外部用户的输入进行检查，例如对包含引号，分号，百分号一些 SQL 语句的保留符号进行限制或者替换
        - 在服务器处理提交数据之前对数据和发型检测，包括数据类型、数据长度、敏感字符的校验等
        - 对 Web 服务器的出错信息进行处理，屏蔽掉敏感信息后再返回用户
    - 使用安全函数，编写安全代码

## Web 应用安全-XSS 攻击与 CSRF 攻击

- 跨站脚本攻击的定义
    - XSS，跨站脚本攻击，是指攻击者往 Web 页面里插入恶意的 html 代码，当用户访问该网页时，嵌入的恶意代码会在用户的浏览器上执行，从而达到攻击者的特殊目的

- 跨站脚本攻击的原理
    - XSS 攻击通过在网页中嵌入客户端恶意脚本代码，这些恶意代码一般由 JS 编写，JS 可以用来获取用户的 Cookie、改变网页内容和 URL 调转等
    - 因此，存在 XSS 漏洞的网站，攻击者向 Web 页面中注入相应的代码，有可能被攻击者盗取用户 Cookie、网站挂马以及 XSS 蠕虫等
- XSS 攻击步骤
    - 利用浏览器编写并注入恶意代码
    - 执行 js 取得 Cookie 或执行 js 挂马
    - 通过 Cookie 获取用户或者管理员权限，用户权限可以获取用户资料等信息，管理员权限则可以操作站点，获取站点数据
- 跨站脚本攻击的危害
    - 盗取用户 Cookie，攻击者利用 XSS 在网页中插入 Cookie 窃取的恶意脚本，一旦用户访问该网页，恶意脚本就会自动执行并把 Cookie 发送给目击者
    - 网站挂马，攻击者利用漏洞制作木马服务器，将木马服务器的 url 插入到一个存在 XSS 漏洞的正常 Web 服务器中
    - XSS 蠕虫，借助 ajax 技术实现对 Web 应用程序中存在的 XSS 漏洞进行自动化利用，传播的蠕虫病毒
- 跨站脚本攻击分类
    - 反射型 XSS
        - 非持久型 XSS
        - 通过诱导用户去点击一些带有恶意脚本参数的 url 而发起
    - 存储型 XSS
        - 持久型
        - 不需要交互也能触发
    - DOM 型 XSS
        - 不依赖于服务端参与解析
        - 浏览器（客户端）在 DOM 解析时直接触发
- XSS 漏洞修复
    - XSS 形成的原因是对输入输出没有严格过滤，需要将敏感字符过滤，即可修补 XSS 跨站漏洞
    - 对用户所有提交内容进行验证
        - 验证内容包括查询关键字，http 头，post 数据等，如<>、<img>、<a>
        - 在表单提交或者 url 参数传递前都要对其进行转换编码，这样浏览器就不会对该标签进行解释执行，同时也不影响显示效果
    - 严格控制输入字符字数
        - 通过限制长度强制裁断进行防御
    - 过滤特殊字符输入
        - 多次过滤，例如<scrip<script>t>过滤掉<script>之后还是<script>
        - 注意多个过滤器的先后次序
- 跨站请求伪造攻击
    - 跨站请求伪造，CSRF 或者 XSRF，是一种对网站的恶意利用
    - CSRF 攻击就是攻击者利用网站对用户网页浏览器的信任，挟持用户当前已登陆的 Web 应用程序，去执行并非用户本意的操作
    - 危害
        - 攻击者盗用用户身份，发送恶意请求
        - 窃取用户的隐私数据造成用户隐私泄露
        - 制造 CSRF 蠕虫
